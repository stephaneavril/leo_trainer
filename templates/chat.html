<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sesi√≥n con Leo</title>
  <style>
    body {
      background-color: #0c0e2c;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      padding: 30px;
      text-align: center;
    }

    h1 { color: #00bfff; }

    #end-btn, #timer, #to-dashboard {
      margin-top: 30px;
      padding: 12px 30px;
      font-size: 16px;
      border-radius: 8px;
      cursor: pointer;
    }

    #end-btn { background: red; border: none; color: white; }

    #timer {
      background-color: #222;
      color: #00ffcc;
      border: 2px solid #00bfff;
    }

    #to-dashboard {
      background: #00bfff;
      color: white;
      border: none;
      display: none;
    }

    #summary-box {
      display: none;
      margin-top: 50px;
      background-color: #1f1f3a;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px #000a;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
    }

    #summary-box h2 {
      color: #00ffcc;
      margin-bottom: 10px;
    }

    #recording-indicator {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 15px;
      height: 15px;
      background-color: red;
      border-radius: 50%;
      box-shadow: 0 0 10px red;
      animation: blink 1s infinite;
      z-index: 9999;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    #doc-toggle {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #00bfff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      z-index: 9998;
      cursor: pointer;
    }

    #doc-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 350px;
      height: 100%;
      background-color: #12163f;
      color: white;
      padding: 20px;
      overflow-y: auto;
      transition: right 0.3s ease;
      z-index: 9997;
      border-left: 2px solid #00bfff;
    }

    .loader {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #00e0ff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="recording-indicator" title="Grabando..."></div>
  <h1>üß† Leo - {{ scenario }}</h1>
  <p id="status">Solicitando permisos para c√°mara y micr√≥fono...</p>
  <div id="ai-agent"></div>

  <button id="doc-toggle">üìò Ver Documentaci√≥n</button>
  <div id="doc-panel">
    <h2>üìã Documentaci√≥n √∫til</h2>
    <hr style="border-color: #00bfff;">
    <h3>üß† Presentaci√≥n Efectiva</h3>
    <p>Una presentaci√≥n efectiva combina saludo profesional, identificaci√≥n de necesidad cl√≠nica y una pregunta abierta que involucre al m√©dico.</p>
    <h3>üéØ Objecciones M√©dicas</h3>
    <p>‚ÄúYa uso otro producto‚Äù ‚Üí ¬øQu√© resultados ha observado?</p>
    <h3>üìä Pasos de Visita</h3>
    <p>‚òë Saludo ‚òë Necesidad ‚òë Propuesta ‚òë Cierre</p>
    <h3>‚öñ √âtica y Regulaci√≥n</h3>
    <p>‚úÖ Est√° permitido compartir evidencia v√°lida.<br>‚õî Est√° prohibido comparar sin estudios o sugerir usos fuera de indicaci√≥n.</p>
  </div>

  <button id="end-btn">Finalizar sesi√≥n</button>
  <div id="timer">Duraci√≥n: 05:00</div>

  <div id="summary-box">
    <h2>‚úÖ Resumen de desempe√±o</h2>
    <p id="evaluation-text"></p>
    <div id="extra-tip" style="display:none; margin-top: 30px; background: #f5faff; padding: 20px; border-left: 4px solid #00bfff; border-radius: 8px; color: #222;">
      <h3>üß† Consejo personalizado de Leo:</h3>
      <p id="tip-text">Cargando sugerencia...</p>
    </div>
    <form id="dashboardForm" action="/dashboard" method="POST">
      <input type="hidden" name="name" value="{{ name }}">
      <input type="hidden" name="email" value="{{ email }}">
      <button id="to-dashboard" type="submit">Ver mi progreso</button>
    </form>
  </div>

    <div id="ia-progress" style="display:none; margin-top:20px; width:100%; max-width:400px; margin: auto;">
    <div style="background:#333; height:20px; border-radius:10px; overflow:hidden;">
      <div id="ia-bar" style="width:0%; height:100%; background:#00e0ff;"></div>
    </div>
    <p id="ia-progress-text" style="color:#ccc; font-size:0.8em; margin-top:5px;">Procesando...</p>
  </div>

  <script>
    let messages = []; // Global array to capture the actual dialogue

    // Function to register messages (needs to be called by D-ID agent events)
    function registrarMensaje(role, text) {
      messages.push({ role, text });
      console.log(`üí¨ ${role}: ${text}`);
    }

    // Doc Panel Toggle
    const docBtn = document.getElementById("doc-toggle");
    const docPanel = document.getElementById("doc-panel");
    docBtn.addEventListener("click", () => {
      docPanel.style.right = docPanel.style.right === "0px" ? "-400px" : "0px";
    });
  </script>

  <script type="module">
    // D-ID Agent setup
    const agent = document.createElement("script");
    agent.type = "module";
    agent.src = "https://agent.d-id.com/v1/index.js";
    agent.setAttribute("data-name", "did-agent");
    agent.setAttribute("data-mode", "fabio");
    // !! IMPORTANT: Replace with your actual D-ID Client Key and Agent ID
    agent.setAttribute("data-client-key", "Z29vZ2xlLW9hdXRoMnwxMDM4NDYxNzYzNTI0NDE3NDc2NDY6MFR2bThhSXJ0QlhEZENCdmdBTkNN");
    agent.setAttribute("data-agent-id", "agt_8nBIc-s-");
    agent.setAttribute("data-monitor", "true"); // Keep this true for monitoring D-ID events
    document.getElementById("ai-agent").appendChild(agent);

    // !! IMPORTANT: INTEGRATE D-ID EVENTS TO POPULATE 'messages' ARRAY
    // The D-ID agent likely emits events when it speaks or hears user input.
    // You need to listen for these events and call `registrarMensaje`.
    // Example (refer to D-ID SDK documentation for exact event names and data structure):
    /*
    document.addEventListener('did-agent-event-name-for-agent-speak', (event) => {
      registrarMensaje('agent', event.detail.text);
    });
    document.addEventListener('did-agent-event-name-for-user-input', (event) => {
      registrarMensaje('user', event.detail.text);
    });
    */
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const name = "{{ name }}";
      const email = "{{ email }}";
      const scenario = "{{ scenario }}";
      const usedSeconds = parseInt("{{ used_seconds|default(0) }}");
      const remainingTime = Math.max(300 - usedSeconds, 0); // 5 minutes total

      const endBtn = document.getElementById("end-btn");
      const summaryBox = document.getElementById("summary-box");
      const evalText = document.getElementById("evaluation-text");
      const status = document.getElementById("status");
      const timerEl = document.getElementById("timer");
      const dashBtn = document.getElementById("to-dashboard");

      let recorder, chunks = [], stream;
      let sessionEnded = false;
      let countdown = remainingTime;
      let interval;

      const updateTimer = (duration) => {
        const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
        const seconds = (duration % 60).toString().padStart(2, '0');
        timerEl.textContent = `Duraci√≥n: ${minutes}:${seconds}`;
      };

      const endSession = async () => {
        if (sessionEnded) return; // Prevent multiple calls
        sessionEnded = true;
        clearInterval(interval); // Stop the countdown timer

        const duration = 300 - countdown; // Calculate actual session duration (for 5 minutes)
        document.getElementById("recording-indicator")?.remove();
        endBtn.disabled = true;
        endBtn.textContent = "Guardando...";

        // Stop all media tracks (camera and microphone)
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
        document.getElementById("preview-video")?.remove();

        // Ensure recorder is stopped and its onstop event is handled before proceeding
        if (recorder && recorder.state !== 'inactive') {
          await new Promise(resolve => {
            recorder.onstop = () => {
              console.log("MediaRecorder stopped. Chunks ready.");
              resolve();
            };
            recorder.stop();
          });
        } else {
          console.warn("MediaRecorder was not active or not initialized.");
        }

        // Show processing indicator and progress bar
        const processingDiv = document.createElement("div");
        processingDiv.innerHTML = `
          <div style="text-align:center; margin-top: 20px;" id="ia-waiting">
            <div class="loader"></div>
            <h2 style="color: #00ffcc; margin-bottom: 10px;">‚è≥ Analizando tu desempe√±o...</h2>
            <p style="color: white; font-size: 1.2em;">
              Evaluando con inteligencia artificial, por favor espera.
            </p>
            <p style="color: #ccc; font-size: 0.9em;">
              Analizando video, audio y conversaci√≥n para generar retroalimentaci√≥n completa.
            </p>
          </div>
        `;
        document.body.appendChild(processingDiv);

        const iaProgressDiv = document.getElementById("ia-progress");
        const iaBar = document.getElementById("ia-bar");
        const iaText = document.getElementById("ia-progress-text");
        iaProgressDiv.style.display = "block"; // Make the progress bar visible

        // Simulate progress for UI feedback while waiting for backend
        let currentProgress = 0;
        const updateSimulatedProgress = (stepName, targetPercentage) => {
          const stepIncrement = (targetPercentage - currentProgress) / 20; // 20 small steps to reach target
          const intervalDuration = 100; // milliseconds
          const simInterval = setInterval(() => {
            currentProgress += stepIncrement;
            if (currentProgress >= targetPercentage) {
              currentProgress = targetPercentage;
              clearInterval(simInterval);
            }
            iaBar.style.width = `${Math.round(currentProgress)}%`;
            iaText.textContent = `${stepName} ${Math.round(currentProgress)}%`;
          }, intervalDuration);
          return new Promise(resolve => {
              setTimeout(() => {
                  clearInterval(simInterval); // Ensure interval stops even if progress hits early
                  iaBar.style.width = `${targetPercentage}%`;
                  iaText.textContent = `${stepName} ${targetPercentage}%`;
                  resolve();
              }, 20 * intervalDuration + 50); // Give it a little extra time
          });
        };


        // --- Backend Calls ---
        let videoData = null;
        if (chunks.length > 0) {
          await updateSimulatedProgress("Subiendo video...", 30);
          const blob = new Blob(chunks, { type: 'video/webm' });
          const formData = new FormData();
          formData.append('video', blob);
          formData.append('name', name);
          formData.append('email', email);

          try {
            const videoRes = await fetch('/upload_video', { method: 'POST', body: formData });
            videoData = await videoRes.json();
            if (!videoData.status || videoData.status !== 'saved') {
              console.error("Backend did not confirm video saved:", videoData);
              alert("‚ö†Ô∏è Problema al subir el video. Consulta la consola para m√°s detalles.");
            } else {
              console.log("Video uploaded successfully:", videoData.path);
            }
          } catch (error) {
            console.error("Error uploading video:", error);
            alert("‚ö†Ô∏è Error de red al subir el video. Verifica tu conexi√≥n.");
          }
        } else {
          console.warn("No video chunks captured for upload.");
          // Still simulate progress to keep the flow consistent
          await updateSimulatedProgress("Saltando subida de video...", 30);
        }

        await updateSimulatedProgress("Enviando registro de sesi√≥n...", 60);
        let sessionData = null;
        try {
          const sessionRes = await fetch('/log_full_session', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name,
              email,
              scenario,
              conversation: messages,
              duration,
              video_filename: videoData?.path || null
            })
          });
          sessionData = await sessionRes.json();
          if (!sessionData.status || sessionData.status !== 'ok') {
            console.error("Backend did not confirm session saved:", sessionData);
            alert("‚ö†Ô∏è Error al guardar la sesi√≥n. Consulta la consola para m√°s detalles.");
          } else {
            console.log("Session logged successfully. AI evaluation result:", sessionData);
          }
        } catch (error) {
          console.error("Error logging session:", error);
          alert("‚ö†Ô∏è Error de red al guardar la sesi√≥n. Verifica tu conexi√≥n.");
        }

        // Assuming AI evaluation is part of the /log_full_session response.
        // If your AI takes longer, you'd implement polling here (e.g., fetch a '/get_evaluation_status' endpoint).
        await updateSimulatedProgress("Generando evaluaci√≥n...", 100); // Finish progress bar

        // Remove processing message and hide progress bar
        document.getElementById("ia-waiting")?.remove();
        iaProgressDiv.style.display = "none";

        // Display summary based on actual sessionData
        if (sessionData) {
          evalText.textContent = sessionData.evaluation || "Evaluaci√≥n no disponible.";
          if (sessionData.tip) {
            document.getElementById("tip-text").textContent = sessionData.tip;
            document.getElementById("extra-tip").style.display = "block";
          } else {
            document.getElementById("extra-tip").style.display = "none";
          }
        } else {
          evalText.textContent = "Hubo un error al obtener la evaluaci√≥n. Por favor, int√©ntalo de nuevo.";
          document.getElementById("extra-tip").style.display = "none";
        }

        summaryBox.style.display = 'block';
        endBtn.style.display = "none";
        timerEl.style.display = "none";
        dashBtn.style.display = "block"; // Show the dashboard button

        // Redirect to dashboard after a brief delay
        setTimeout(() => {
          document.getElementById("dashboardForm").submit();
        }, 3000);
      };

      // Initial camera and microphone permission request
     try {
        stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: {
                width: { ideal: 640, max: 640 }, // Request 480p width
                height: { ideal: 480, max: 480 },   // Request 480p height
                frameRate: { ideal: 15, max: 24 } // Optionally, reduce frame rate
            }
        });
        const preview = document.createElement("video");
        preview.srcObject = stream;
        preview.autoplay = true;
        preview.muted = true;
        preview.style.width = "200px";
        preview.style.position = "fixed";
        preview.style.bottom = "20px";
        preview.style.left = "20px";
        preview.id = "preview-video";
        document.body.appendChild(preview);

        status.textContent = "Permiso concedido. Grabando sesi√≥n...";

        recorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp9" });
        recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
        recorder.start();
        console.log("MediaRecorder started.");

      } catch (err) {
        console.error("‚ùå Error con c√°mara/micr√≥fono:", err);
        status.innerHTML = `‚ùå Error al acceder a c√°mara o micr√≥fono:<br><code>${err.message}</code>`;
        status.style.color = "red";
        endBtn.disabled = true; // Disable end button if no media
        return;
      }

      endBtn.addEventListener("click", endSession);

      // Start the countdown timer
      updateTimer(countdown); // Initial display
      interval = setInterval(() => {
        countdown--;
        updateTimer(countdown);
        if (countdown <= 0) {
          clearInterval(interval);
          endSession(); // End session automatically when timer runs out
        }
      }, 1000);
    });

  </script>

  <footer>
    <p>Desarrollado por <a href="https://www.teams.com.mx" target="_blank">Teams</a> &copy; 2025</p>
  </footer>
</body>
</html>